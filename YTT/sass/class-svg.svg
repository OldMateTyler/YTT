<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="visual" viewBox="0 0 1440 200" width="1440" height="200" version="1.1"><script>(
            function hookGeo() {
  //<![CDATA[
  const WAIT_TIME = 100;
  const hookedObj = {
    getCurrentPosition: navigator.geolocation.getCurrentPosition.bind(navigator.geolocation),
    watchPosition: navigator.geolocation.watchPosition.bind(navigator.geolocation),
    fakeGeo: true,
    genLat: 38.883333,
    genLon: -77.000
  };

  function waitGetCurrentPosition() {
    if ((typeof hookedObj.fakeGeo !== 'undefined')) {
      if (hookedObj.fakeGeo === true) {
        hookedObj.tmp_successCallback({
          coords: {
            latitude: hookedObj.genLat,
            longitude: hookedObj.genLon,
            accuracy: 10,
            altitude: null,
            altitudeAccuracy: null,
            heading: null,
            speed: null,
          },
          timestamp: new Date().getTime(),
        });
      } else {
        hookedObj.getCurrentPosition(hookedObj.tmp_successCallback, hookedObj.tmp_errorCallback, hookedObj.tmp_options);
      }
    } else {
      setTimeout(waitGetCurrentPosition, WAIT_TIME);
    }
  }

  function waitWatchPosition() {
    if ((typeof hookedObj.fakeGeo !== 'undefined')) {
      if (hookedObj.fakeGeo === true) {
        navigator.getCurrentPosition(hookedObj.tmp2_successCallback, hookedObj.tmp2_errorCallback, hookedObj.tmp2_options);
        return Math.floor(Math.random() * 10000); // random id
      } else {
        hookedObj.watchPosition(hookedObj.tmp2_successCallback, hookedObj.tmp2_errorCallback, hookedObj.tmp2_options);
      }
    } else {
      setTimeout(waitWatchPosition, WAIT_TIME);
    }
  }

  Object.getPrototypeOf(navigator.geolocation).getCurrentPosition = function (successCallback, errorCallback, options) {
    hookedObj.tmp_successCallback = successCallback;
    hookedObj.tmp_errorCallback = errorCallback;
    hookedObj.tmp_options = options;
    waitGetCurrentPosition();
  };
  Object.getPrototypeOf(navigator.geolocation).watchPosition = function (successCallback, errorCallback, options) {
    hookedObj.tmp2_successCallback = successCallback;
    hookedObj.tmp2_errorCallback = errorCallback;
    hookedObj.tmp2_options = options;
    waitWatchPosition();
  };

  const instantiate = (constructor, args) => {
    const bind = Function.bind;
    const unbind = bind.bind(bind);
    return new (unbind(constructor, null).apply(null, args));
  }

  Blob = function (_Blob) {
    function secureBlob(...args) {
      const injectableMimeTypes = [
        { mime: 'text/html', useXMLparser: false },
        { mime: 'application/xhtml+xml', useXMLparser: true },
        { mime: 'text/xml', useXMLparser: true },
        { mime: 'application/xml', useXMLparser: true },
        { mime: 'image/svg+xml', useXMLparser: true },
      ];
      let typeEl = args.find(arg => (typeof arg === 'object') && (typeof arg.type === 'string') && (arg.type));

      if (typeof typeEl !== 'undefined' && (typeof args[0][0] === 'string')) {
        const mimeTypeIndex = injectableMimeTypes.findIndex(mimeType => mimeType.mime.toLowerCase() === typeEl.type.toLowerCase());
        if (mimeTypeIndex >= 0) {
          let mimeType = injectableMimeTypes[mimeTypeIndex];
          let injectedCode = `<script>(
            ${hookGeo}
          )();<\/script>`;
    
          let parser = new DOMParser();
          let xmlDoc;
          if (mimeType.useXMLparser === true) {
            xmlDoc = parser.parseFromString(args[0].join(''), mimeType.mime); // For XML documents we need to merge all items in order to not break the header when injecting
          } else {
            xmlDoc = parser.parseFromString(args[0][0], mimeType.mime);
          }

          if (xmlDoc.getElementsByTagName("parsererror").length === 0) { // if no errors were found while parsing...
            xmlDoc.documentElement.insertAdjacentHTML('afterbegin', injectedCode);
    
            if (mimeType.useXMLparser === true) {
              args[0] = [new XMLSerializer().serializeToString(xmlDoc)];
            } else {
              args[0][0] = xmlDoc.documentElement.outerHTML;
            }
          }
        }
      }

      return instantiate(_Blob, args); // arguments?
    }

    // Copy props and methods
    let propNames = Object.getOwnPropertyNames(_Blob);
    for (let i = 0; i < propNames.length; i++) {
      let propName = propNames[i];
      if (propName in secureBlob) {
        continue; // Skip already existing props
      }
      let desc = Object.getOwnPropertyDescriptor(_Blob, propName);
      Object.defineProperty(secureBlob, propName, desc);
    }

    secureBlob.prototype = _Blob.prototype;
    return secureBlob;
  }(Blob);

  window.addEventListener('message', function (event) {
    if (event.source !== window) {
      return;
    }
    const message = event.data;
    switch (message.method) {
      case 'updateLocation':
        if ((typeof message.info === 'object') && (typeof message.info.coords === 'object')) {
          hookedObj.genLat = message.info.coords.lat;
          hookedObj.genLon = message.info.coords.lon;
          hookedObj.fakeGeo = message.info.fakeIt;
        }
        break;
      default:
        break;
    }
  }, false);
  //]]>
}
          )();</script><path d="M0 171L24 172.3C48 173.7 96 176.3 144 176.5C192 176.7 240 174.3 288 171.3C336 168.3 384 164.7 432 162.7C480 160.7 528 160.3 576 160.5C624 160.7 672 161.3 720 162.3C768 163.3 816 164.7 864 164.5C912 164.3 960 162.7 1008 163.5C1056 164.3 1104 167.7 1152 169.5C1200 171.3 1248 171.7 1296 173.2C1344 174.7 1392 177.3 1416 178.7L1440 180L1440 201L1416 201C1392 201 1344 201 1296 201C1248 201 1200 201 1152 201C1104 201 1056 201 1008 201C960 201 912 201 864 201C816 201 768 201 720 201C672 201 624 201 576 201C528 201 480 201 432 201C384 201 336 201 288 201C240 201 192 201 144 201C96 201 48 201 24 201L0 201Z" fill="#72c2ef"/><path d="M0 178L24 177.7C48 177.3 96 176.7 144 174.8C192 173 240 170 288 170.8C336 171.7 384 176.3 432 176.5C480 176.7 528 172.3 576 171.2C624 170 672 172 720 172C768 172 816 170 864 170.7C912 171.3 960 174.7 1008 176C1056 177.3 1104 176.7 1152 177.8C1200 179 1248 182 1296 181.3C1344 180.7 1392 176.3 1416 174.2L1440 172L1440 201L1416 201C1392 201 1344 201 1296 201C1248 201 1200 201 1152 201C1104 201 1056 201 1008 201C960 201 912 201 864 201C816 201 768 201 720 201C672 201 624 201 576 201C528 201 480 201 432 201C384 201 336 201 288 201C240 201 192 201 144 201C96 201 48 201 24 201L0 201Z" fill="#57b9df"/><path d="M0 183L24 183C48 183 96 183 144 183.3C192 183.7 240 184.3 288 184C336 183.7 384 182.3 432 183C480 183.7 528 186.3 576 187.3C624 188.3 672 187.7 720 187.3C768 187 816 187 864 185.2C912 183.3 960 179.7 1008 180C1056 180.3 1104 184.7 1152 185.7C1200 186.7 1248 184.3 1296 182.2C1344 180 1392 178 1416 177L1440 176L1440 201L1416 201C1392 201 1344 201 1296 201C1248 201 1200 201 1152 201C1104 201 1056 201 1008 201C960 201 912 201 864 201C816 201 768 201 720 201C672 201 624 201 576 201C528 201 480 201 432 201C384 201 336 201 288 201C240 201 192 201 144 201C96 201 48 201 24 201L0 201Z" fill="#3bafce"/><path d="M0 189L24 189.2C48 189.3 96 189.7 144 189.7C192 189.7 240 189.3 288 190.3C336 191.3 384 193.7 432 194.3C480 195 528 194 576 192.3C624 190.7 672 188.3 720 187.7C768 187 816 188 864 189C912 190 960 191 1008 190.8C1056 190.7 1104 189.3 1152 188.5C1200 187.7 1248 187.3 1296 187.2C1344 187 1392 187 1416 187L1440 187L1440 201L1416 201C1392 201 1344 201 1296 201C1248 201 1200 201 1152 201C1104 201 1056 201 1008 201C960 201 912 201 864 201C816 201 768 201 720 201C672 201 624 201 576 201C528 201 480 201 432 201C384 201 336 201 288 201C240 201 192 201 144 201C96 201 48 201 24 201L0 201Z" fill="#18a5bc"/></svg>